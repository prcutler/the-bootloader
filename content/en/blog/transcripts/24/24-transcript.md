---
date: 2025-08-25
title: "Episode 24 Transcript"
linkTitle: "Episode 24 Transcript"
description: "Episode 24 Transcript - CircuitPython Day 2025"
author: Paul Cutler ([@prcutler](https://hachyderm.io/@prcutler))
---


Paul Cutler
Welcome to the Bootloader, I'm Paul Cutler. Along with my co-host Tod Kurt, we were invited to participate in CircuitPython Day 2025 on August 15th, and we recorded a live episode of the Bootloader. This is a lightly edited replay, and you can listen to the episode or watch us on YouTube, which I've linked to in the show notes. Now here's Tod and I with some of our favorite things from CircuitPython and the community from the last year. Welcome to the Bootloader, I'm Paul Cutler.

Tod Kurt
And I'm Tod Kurt. We're coming to you live on the Adafruit YouTube channel for CircuitPython Day 2025. If you haven't heard of us, Paul and I host a podcast called The Bootloader. Each episode, we bring a few things to share and chat about for a few minutes each, no more than about five minutes. And today we brought you some of our favorite things that have happened in the CircuitPython community in the last year. You can learn more about us at thebootloader.net or find us wherever you get your podcasts.

Paul Cutler
And if you wanna chat with us live, you can find us in the live broadcast chat channel on the Adafruit Discord at discord.gg/adafruit. Tod, before we get started, I wanted to take a moment and give a shout out to Anne Borella. Anne is the editor of the Python on Hardware weekly newsletter, and I don't think we could do this show or my other podcast, The Circuit Python Show without her and the newsletter. It's the best way to stay on top of everything related to Python and hardware. I had the opportunity a couple of years ago to help fill in for Anne when she was on vacation for a couple of weeks, and let me tell you, It is a ton of work to stay connected in multiple communities and bring you all the news every week. So go sign up if you haven't and Anne, from us to you, a big thank you.

Tod Kurt
Yeah, thanks Anne. And it's not just CircuitPython. It's like pretty much any time you see embedded Python. It could be on a Raspberry Pi. It could be MicroPython.

Paul Cutler
Tod, what's your first thing to share?

Tod Kurt
Alright, so fonts. CircuitPython fonts. So let me turn it to a little down shooter here. Not these things, not yet. this thing. So one of the really cool things about CircuitPython is that it's really easy to get a display going. This is the little T-Display S3. The underlying Display.io framework in CircuitPython makes it not matter whether you're using a TFT display like this or an OLED or ePaper, LED matrix, your display code can really be the same for all these. And that goes well as well to the fonts. The CircuitPython font system loads these BDF and PCF format have been around for 30 plus years on Unix systems. I used to worry about my bitmap fonts back in the early days of Linux. There are tools to convert modern TrueType or OpenType fonts that are like these scalable vectors to the old bitmap format if you need to. There's a great learn guide on the Adafruit Learn Guide that tells you how to do this. But doing this conversion is tricky, it can be a drag at times. So I was really excited when last year, there was a effort by Jeff Epler to make a package, a bundle of a bunch of pre-converted fonts. The really cool thing is that the bundle is set up such that you can use it with CircUp. So all you have to do is, the instructions are in the repo, you just add this bundle to your CircUp setup. By the way, CircUp, if you've not used it, it's like PIP for CircuitPython, a package manager for CircuitPython, really handy. If you're using the CircuitPython plugin for VS Code, I believe it also works the same way. But once you have the bundle installed to Circup, you can say Circup install font, font name, whatever of the many fonts. If you look in the number of fonts that's in this repo, there are hundreds. They're stored as true type, so you could learn how the conversion process works, by looking at this repo as well, which is pretty cool. This little demo I have in the bottom right is showing me loading a bunch of fonts. What that code looks like, it's really simple. I'll show you using my favorite terminal program, or my favorite text program, Emacs. You circ up install a bunch of fonts, like whichever font you want. In this case, I'm installing all these fonts. Then in your code, you just load them like Python packages, which is pretty nice. Then you can do whatever you want. In this case, I've made a little list of all the packages, and I'm just going through this list to display the fonts with various colors. And that's what the rest of this code is. It's not very exciting. It's basically just standard display IO stuff. It does also obey the buttons so I can speed up or reverse the scrolling. Oops, except I can't go that way 'cause I haven't actually fixed that part. (laughs) So yeah, we can scroll really fast. And some of these fonts are really great. Like you get some really pro-looking results, but just by having a really good font. So it's really cool. I really love this the CircuitPython fonts package. I've been using it for some of my things. By the way, if you want a good CircuitPython board that has a beautiful display, this T-Display S3 is really nice. Let me make it a little bit bigger. And this is pretty cheap, but it runs, it's an ESP32 S3 that can do Wi-Fi and stuff like that. But anyway, that's the CircuitPython font package. Try it out if you have to do anything with displays.

Paul Cutler
So when you're installing that via circup, how do you decide what size fonts to install or to try first?

Tod Kurt
Whoo. Yeah, that's a good that's a good point Like in this case, I'm doing a big demo and I just wanted the biggest fonts possible So I chose size 48 and I didn't I haven't figured out if 48 means 48 points or 48 pixels high Oops, I think it means 48 pixels high just from the resolution of the screen, but I'm not sure So it's one of the things that he'd look at he's he's pre created a bunch of different common sizes 12, 24, 36, 48, eight for really small display, like status display type of fonts. But this is what 48 looks like on a 320 by 240 display, I think. Sure. I forget what the resolution is of this one, it's nice, oh actually maybe it says on the box. Nope. Anyway, I'll put a link to this gizmo, they've got a pretty good wiki about it, And I'll put a link to my code in the show notes or the Discord. But yeah, so it kind of depends on the kind of the information you're wanting to display. If it's something big and big and label-y like this to be seen across the room, then a 48 size is pretty good. For the CircuitPython REPL, which I can show that real quick here. If we go into the REPL. So I think that's a size 8 font. So you can get a lot of information on the screen, but it's really hard to read from across the room. So pick your poison. What works for your particular application, I think is the real answer.

Paul Cutler
Sure. Makes sense.

Tod Kurt
All right. So what do you have for us this time?

Paul Cutler
Late last November, Will Merkens released version 0.2 of the CircuitPython extension for VS Code. This is a fork of the original extension by Joe DeVivo, which hadn't been updated since late 2023. A thank you to Joe DeVivo for creating this extension and licensing it under the MIT license. That allowed Will Merkens to fork it, and a big shout out for taking this on. It's never easy to fork someone's project, figure out someone else's code, and then add to it. And every time CircuitPython has had a major release, the extension has been updated. If you're a VS Code user, you can install the extension by going to View Extensions and search for CircuitPython. Let me bring up VS Code. You can click on the extensions, type CircuitPython, and you'll see that it comes up with the V2 and the original. Make sure that you choose the V2, which I have installed. Once you have it installed, all you need to do is open your directory, open a folder that contains your CircuitPy drive, and the extension will automatically kick in.

Tod Kurt
Oh, that's all you do is just open up the whole CircuitPy drive as a folder in VS Code. I haven't used it yet.

Paul Cutler
 That's all you do. It sees that if it's main.py or code.py or a couple others, it automatically enables the extension. So from there, you want to choose a board, and I've got a couple of boards plugged in, but one board that I'm using right now is the seed.jow.senseboard. Once you have that selected, you can do fun things like auto-completes. So here's the pins, the charge rate, the charge status. I bet there's a microphone one in here somewhere. If I'm, yep, there's the mic power. So all of that auto-complete, what you would expect in an IDE comes to life through this extension. That's cool. Now, if you bring up the command palette with shift command P and then type circuit Python as well, you can see all the different commands that are available to you. So you can show available libraries. That shows all libraries that are installable. You can list the project libraries that you have installed on your device, it automatically downloads and checks for the latest bundle that of libraries when you first install the extension and every time you open VS Code as well. You can choose the board, you can mess with the serial monitor, and you can update all libraries, which is probably one of my favorite things. This was inspired by the circup update --all command, but this works just for the VS Code extension.

Tod Kurt
Yeah, that's really handy 'cause right now we're at this cusp between CircuitPython 9 being the regular official version, CircuitPython 10, and the library file format changes between big versions like that. So we're going to have to update our library soon if you're not already playing with version 10.

Paul Cutler
And then the other thing you can do is it's really easy to open the serial monitor. You just hit the little button in the bottom right-hand corner. You can see that I have a couple different boards plugged in. Oh, doesn't like that. I don't know why that board isn't working. Of course, doing it live, something's got to go wrong. But that's the CircuitPython v2 extension for VS Code. A big shout out to Will Merkens for bringing it back and keeping it updated this past year. And if VS Code isn't your thing, check out Professor Gallaugher's YouTube channel for a great guide on setting up PyCharm and Tio as an alternative as well.

Tod Kurt
Totally. Yeah, so how do you change the different board types? Because I use a bunch of different CircuitPython boards. Like I think you covered it quickly, but I kind of missed it. What was the, like, where do you go and select which board kind you're using?

Paul Cutler
If you haven't chosen a board yet where it says XIAO and NRF 52840 Sense here would say choose board. Oh, wow, okay. So you'd click that and then you can scroll through and you'll see every board that has had a release on circuitpython.org. Okay, I see, yeah. So the extension's only up to using CircuitPython 9.2.x. that doesn't include the 10.0 betas. It only has the full releases. So for example, the fruit jam won't be in there until the 10.0 final comes out and the extension is updated with that. And then it will pull in all the latest boards as well.

Tod Kurt
Yeah. Okay. That's pretty cool. That was the main thing that stymied me when I tried it. And I might've been trying the version one. I just could not get like, how do we select the board?

Paul Cutler
Yup. And it's one of the more popular questions in the Discord is which IDE should I use? With mu being sunset this year. It's nice to see that someone in the community Stood up took this on and shared it with everyone. So it's just great to have another alternative out there as well.

Tod Kurt
No kidding.

Paul Cutler
All right. What's your next one for us Tod?

Tod Kurt
I'm getting my I get my demo ready here Um, see if it comes up. All right, so this is a fruit jam product project So the fruit jam, it's like a little computer. It's got video out. It's got keyboard and mouse in basically You really want to treat it like a little computer But man doing doing all this what the free gem does is is it's kind of hard especially acting as a USB host like one of the things that USB does did is it put a lot of the processing of the USB protocol on the computer side of things rather than the peripheral side of things so that your your mouse can be You know pretty pretty dumb but it means that now we have the free gem means the free gem has to do a lot of work on the USB side to Pretend to be a computer to the to the whatever things you plug into it So I was really gratified to see that Sam Blenny on the Adafruit playground site has been doing some really cool stuff with USB host specifically USB MIDI since I'm a real USB MIDI person. One of the things he made is this USB host MIDI tester and so the way it works is you've got a little display of notes here and and the vertical axis is MIDI channel, and then this is like a little status area for like if your thing got plugged in or not. And so I have a lot of these little cheap USB MIDI controllers, which are great, except they're USB only. You can find these, they're so cheap, they're like 20, 30 bucks, but because they're just USB, because they're just USB MIDI and not just MIDI MIDI, it's really hard to use with some of my stuff. But thankfully, we're getting to the point now where we can have microcontrollers that do USB host. And so here's one of Sam's, here's a demo of Sam's little project working, where if I plug in the device, you should see the scanning. Ah, look, it recognized it. And if I start playing on the keyboard, you'll see the little lights on the display figure. And this is an HDMI monitor, right? So like I'm basically being a full computer here, but it's a special purpose MIDI computer. And so if I turn it off and turn it back on again, it actually comes up much faster a computer would come up, like boom, there, it's running again. You know, now one of the downsides of the current way that USB host works on Circuit Python, by the way, this is all Circuit Python, which is just amazing, is it doesn't do device removal detection very well. Like you saw it detected immediately the USB device plug-in, but if I plug in something else, it also does not necessarily do that. It's like there's a ghost of the previous connection hiding in the system and so this doesn't quite work. But you know, right now you can just reset and just in two seconds, it comes back up and now the new device is detected. And so this is, I think, is what I said, it's gonna be fixed as things get more and more developed. This has been one of the first real, the FreeJams have been one of the first real good things to play with USB. And so I think we're gonna see USB hosts get better and better really quickly. This is really exciting because now this is a path towards making all these random little MIDI keyboards I have that are just USB and you do something better. Oh, and also I wanted to give a shout out to Sam's Adafruit Playground page in general 'cause there's a lot of really good stuff there for learning just techniques in CircuitPython and he's just publishing all the details. For instance, his somewhere way down here is the Fruit Jam MIDI tester, but he published this months ago. Since then, he's made this full portable MIDI synth. It runs off a battery, uses the Fruit Jam and a USB MIDI keyboard. So you could put in your backpack, go play somewhere. One of the other really useful things is here's a gamepad tester. So it's like two USB gamepads. I think Adafruit sells some. So this helps you test out, do these gamepads actually work with the Fruit Jam. So yeah, thank you, Sam, for doing all this great work. I can't wait to play more with the Fruit Jam with some of the USB host stuff.

Paul Cutler
That's a great segue because I know Sam helped out on my next pick. Oh yeah. That's a nice segue, we'll just jump into it. My next pick might suffer from some recency bias just like yours, but it's just so cool I have to talk about it. It's so new that it hasn't even been in the Python on Hardware newsletter yet, though it was demoed on Show & Tell this week. And that is Fruitris, a Tetris clone for the fruit jam that is running over my shoulder on my fruit jam on my extra monitor on my workbench. The fruit jam has only been out for just two weeks, and already a community member, Cooper Dalrymple has created a Tetris clone. I got to know Cooper earlier this year when he was a guest twice on the CircuitPython show, and you might know of him from his work with Synthio. Fruitris has already had four releases this week and is still considered alpha, but I run into any bugs and no I'm not going to admit to how much time I've played this week when I probably should have been prepping for the show. There's a few different things that are really neat about Fruitris. First, Cooper did some work to detect the display and it now supports widescreen displays and the resolutions and the gameplay region adjusts depending on your resolution. Second, the music is fantastic. Plug in some headphones. It's perfect and retro in an to update synth.io and add a tempo variable, which he puts to good use in Fruitris as the music speeds up as the levels get harder and faster. Third, you can use a game pad or mouse to rotate and drop the bricks. You can find the keyboard shortcuts on the project's Adafruit Playground page, which I have up right here. So he's got a great page that shows everything you need to know about the game, what it's running on, a video demo. Here's the controls, how to configure the display and the NeoPixels, what parts to use, and then about 1600 lines of code. (laughing)

Tod Kurt
Yeah, it is a full application.

Paul Cutler
Yup, yup. It's not for the faint of heart, but he makes excellent use of async IO in here. One of the questions I was asked when I told someone I was playing was if the game was laggy because I was running a game on a microcontroller. And no, it's not, not at all. from the graphics to the sounds to the gameplay, it's really well done. If and when you get a Fruit Jam, make this one of the first things that you install. Totally.

Tod Kurt
Yeah, we've seen a lot of, like ever since Arduino could drive displays, we've seen people implement little video games, like old ladies video games, like Tetris, whatever. But this is running, it's driving a display. It's using a USB keyboard or game pad as input, and it's all written in CircuitPython. (laughs) Just the levels of complexity.

Paul Cutler
We've reached the vision that Scott has talked about for years, right?

Tod Kurt
It's just like the old days. You can plug and play.

Paul Cutler
You plug it into the display like you said earlier, and it instant turns on. And then here we've got a game console. We've got Fruit Jam OS coming where you can have multiple different apps installed at the same time. It's a really exciting time for CircuitPython.

Tod Kurt
Yeah, one of the cool things, it's a really good, as someone who's a Synthio fan, one of the cool things is to, if you're into Synthio, you should look into how he does the music because it really shows the power of what you can do with music synthesis in CircuitPython because he sets up these little synthesizers, little Synth.io synthesizers, and then he has these just standard MIDI files, and he tells Synthio, "Hey, Synthio, play this MIDI file with this synthesizer." And so, and you can do that with multiple synthesizers and multiple MIDI tracks, so that's how he gets the interesting, nice sound out of it. And yeah, it's just like, cool, that's just something you can do a couple lines of CircuitPython.

Paul Cutler
Yep. And he put together a whole game in just a matter of weeks. It's just amazing. Yeah. What's your next pick for us?

Tod Kurt
All right. So do you know that there are four, at least four different ways to program your CircuitPython devices? I'm sure you're aware of the one of the original differences between CircuitPython and MicroPython. CircuitPython only supported devices with native USB. That means devices that could emulate a USB storage device, USB thumb drive and provide us with a CircuitPy drive that we'd normally save our code.py file on. This restriction is really good though, because with just a text editor and the terminal program, you can write CircuitPython programs. Got an old Windows 95 laptop with notepad.exe and putty, you can code on a CircuitPython board. And this is actually not too much different than my setup, which I use TO and Emacs, but I'm not yet into the IDE space. But if you wanna do other ways, If you only use other chips, it used to not be possible, but now there's all these CircuitPython capable boards that don't have native USB, so how do they work? So for the ESP32, the old original ESP32 devices, there's the web workflow where it starts up a little entire web server with file transfer capability and serial emulation. It's pretty amazing, but it does take some CPU resources that maybe you want, 'cause it is just a little microcontroller. Also, the Wi-Fi reception on these little boards is usually not that great compared to what we're expecting from our laptops and stuff. So trying to edit files can get a little frustrating. So I actually have the web workflow stuff turned off just because I'm like, I'll figure out some other purpose. Sorry, I figured out some other way and there's like some command line tools you can use, but it's fiddly. There's also a BLE workflow for the InterF52 Bluetooth-based devices. That's pretty cool. It means you can use potentially to use to edit CircuitPython. I've not tried that much. I have used the serial part of Bluetooth to play with CircuitPython devices, but that's about it. But both of these are wireless. If your connection isn't perfect, it can be frustrating. But now there is a way to do native USB saving and loading of files and editing code on things like on originally ESP32 devices. This is like the way Thonny works with MicroPython if you ever use that, where you have to use the special program to talk to the file system that's somewhere hidden on the device. But the code.circuitpython.org web-based editor does this now too, and it works great. If you use one of the new Sparkle Motion LED driver boards like this one here, you can now edit the code files on this pretty easily. This is all running CircuitPython. Where's my little piece of paper? It's a diffuser. This is all in CircuitPython. The way this works is in the browser, you see now there are these three. I'm seeing these three options because currently there's not a normal CircuitPython device plugged in. But now I've got the three other options the normal one and I can pick USB and I can then say which of the serial devices that I think the device is at and now it'll connect up and you can see that I have both a terminal window, sorry a terminal window and an editor code editor window just as you'd expect. So I can open up the code.py file. This is all pretty standard now what you'd expect. I can go over here and I can ctrl+c the program and restart the program and I can edit the program. Let's make this happen much slower. And then I save and it should restart the code. If not, I can just do this. And so now this happens much slower. And so this is a really pretty good way of editing code on an ESP32 board that doesn't have native USB. And so I'm a big fan. I've been wanting to play with these little Sparkle Motion boards. And now I have an easy way to do it.

Paul Cutler
Yeah, CircuitPython's really known for presenting as a flash drive, right?

Tod Kurt
That's one of the greatest things about it.

Paul Cutler
But there's, to your point, there's multiple different ways. You have choice now in how you want to interact with your drive when you're programming it.

Tod Kurt
Yeah, yeah. And I think a lot of people were throwing aspersions at CircuitPython early on because the old ESP32, the original ESP32 was really popular and it was really popular in micro Python uses in it. And suddenly CircuitPython was like not. So everyone was like, why? Oh, this is not a good thing. Clearly we should use something else other than CircuitPython. But now it's just as easy as using kind of any other CircuitPython style of interaction. So thumbs up.

Paul Cutler
That's right. Well, that's our show. A big thank you to Adafruit for having us today for CircuitPython day and to Liz for being on camera control. You can learn more about us by visiting our homepage at thebootloader.net show wherever you get your podcasts. Coming up next is Game Jam with Phonmyguy at 6 30 PM Eastern. Until next time, stay positive.
