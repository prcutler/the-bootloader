---
date: 2025-11-03
title: "Episode 26"
linkTitle: "Episode 26 - November 3, 2025"
description: "TBD"
author: Paul Cutler ([@prcutler](https://hachyderm.io/@prcutler))
---

## Welcome to the show

Enter summary here.

Follow the show on [Mastodon](https://www.circuitpythonshow.com/@thebootloader/follow) or [Bluesky](https://bsky.app/profile/thebootloader.net).

## Listen to the podcast

Insert iframe from Castopod here.

## Show Notes

### Liz's Pick #1: Raspberry Pi Connect
https://connect.raspberrypi.com/

Raspberry Pi Connect is a service that comes with the new distributions of Raspberry Pi OS. I've been doing a lot of development with Raspberry Pi's recently and I've found it to be really helpful. It lets you access a terminal or screen share session to your Raspberry Pi through your browser and then you can use your desktop mouse, keyboard and monitor to interact with it. The best feature though in my opinion is that you can copy and paste to and from the Pi with it.

### Paul's Pick #1: OpenBook Touch

Joey Castillo has announced the [OpenBook Touch](https://www.crowdsupply.com/oddly-specific-objects/open-book-touch), an
open source e-reader coming soon on Crowd Supply.  Joey is the creator of the Sensor Watch and [Sensor Watch Pro](https://www.crowdsupply.com/oddly-specific-objects/sensor-watch-pro), PCBs that allowed you to upgrade Casio's iconic F-91W watch.  He's been working on the OpenBook Touch for a while, and it's exciting to see it coming soon on Crowd Supply.

It features everything you would expect in an e-reader, including:

* Processor: ESP32-S3 MCU with support for Wi-Fi and Bluetooth
* Program Memory: 16 MB quad SPI Flash
* RAM: 8 MB octal SPI SRAM
* Display: 4.26 inch, 480x800 e-paper display with warm and cool frontlight
* Touchscreen: Capacitive; FT6336 chipset with low power and interrupt capability
* Storage: MicroSD card slot
* Battery: 1800 mAh LiPo with integrated charging and monitoring
* Connector: USB Type-C
* Dimensions: 77 x 118 x 9.6 mm
* Weight: 3 oz (85 grams)

Everything will be open source, including the software, documentation, KiCad schematics, board files and enclosure.

### Tod's Pick #1: atopile: design KiCad circuits with code

You can now design circuit boards with code! Well sorta.

Let's say you want to design a circuit board. As you're both aware (but maybe not some in our audience),
usually that begins with a schematic: a flow-chart-like drawing that describes the logical connections
between the components of your circuit. From the schematic, you then create the PCB board layout.
This is the physical layout with exactly which components you'll be using placed exactly where you want them.
For instance, in your schematic you may just have noted a "500 ohm resistor",
but it's during the laying out the PCB is when you choose exactly which of the
literally thousands of 500 ohm resistors you want.

At the end of this process, you have these two drawings: one for the logical design, one for the physical layout.

But what if instead starting with a schematic, you started with code?
And that code then gets turned into the PCB layout? This is what atopile is attempting to do.
Atopile is a few things. First, it's a Python-inspired domain-specific language for specifying
connectivity between components. In just a few lines you can describe some common sub-circuits
you might often reuse like "LED status light", "keyboard matrix", "voltage regulator", or even
"RP2040 micrcontroller".  Each of these sub-circuits becomes re-usable functions in atopile.

And so atopile is also a package repository, sort of like npmjs or pypi, but the modules it knows
about are these sub-circuits. And like in other languages, you import them at the top of your
file and then use them in your own code, I mean, circuit.

These atopile modules also contain KiCad PCB layout information, which is especially useful
for complicated sub-circuits. For instance, the "rp2040" package contains the entire
KiCad PCB layout for an RP2040 microcontroller circuit, like what is on the Raspberry Pi Pico.
Having those tiny but important details bundled up is really nice.

Once you have your atopile code written, using these modules, use the atopile compiler
to generate the PCB. When you open the board in KiCad, you'll see sub-modules are fully routed,
but the connections between them are not. In theory you'd quickly hand-route do these connections
and the board would be finished.  From code to finished PCB!

That's the dream, and it's not even the end goal. By moving the logical design into
a hierarchical code-like environment, the atopile devs are hoping to leverage LLMs
to help design circuits. They have a first-party atopile VSCode Cursor AI extension to
help with writing atopile code.

I've tried atopile a bit this last week and, while it's interesting, I am skeptical.
It is very new and there are huge gaps in the available packages.

In regular circuit design, there is a back-n-forth between schematic
and PCB design called "forward and backward annotation".
atopile doesn't support this concept: its flow is strictly one-way from code to PCB layout.

KiCad supports "Design Blocks" in its schematic view, which are sort of like
the re-usable modules of atopile, but it doesn't yet have the corresponding PCB layout blocks.
(There are work-arounds for this but it'd be nice if KiCad had this)

Also, I miss schematics! The code view of atopile is nice, but like well-structured code,
a lot of the "implementation" of a circuit is hidden behind the sub-modules. And it's often
crucial to get a holistic view of a circuit to understand where an issue is.

But I'm going to keep playing with atopile.  We used to design FPGAs and ASICs all with
schematics and now they're almost all in VHDL and Verilog, so there's precedent for moving to a
full code-based workflow for circuits.

Links:
- [atopile homepage](https://atopile.io/)
- [atopile package repo](https://packages.atopile.io/)
- [Vibe-coding a PCB](https://atomic14.substack.com/p/vibe-coding-a-pcb-surprisingly-good)
- [KiCad schematic design blocks](https://docs.kicad.org/9.0/en/eeschema/eeschema.html#schematic-design-blocks)

### Liz's Pick #2: MIDI Baby Gen4
https://github.com/DisasterAreaDesigns/MIDI-Baby-Gen4
https://www.disasterareadesigns.com/shop/p/midi-baby

Disaster Area Designs makes a lot of music utility pedals aimed at guitarists. Its operated by Matthew Farrow, who also runs Alexander Pedals. They have a new release for their MIDI Baby pedal, which is a teeny tiny single foot switch that lets you send MIDI messages over TRS, DIN-5 or USB. The Gen4 though has an exciting new feature: it has an RP2040 inside and Matthew has ported it to CircuitPython. He has demo code for it up on GitHub and I'm hoping to do some fun experiments with it.

### Paul's Pick #2: GameTank

* [GameTank.zone](https://gametank.zone)
* [CrowdSupply campaign](https://www.crowdsupply.com/clydeware/gametank)
* [GitHub repository](https://github.com/clydeshaffer/gametank)
* [Emulator](https://github.com/clydeshaffer/GameTankEmulator)
* [Discord Server](https://discord.gg/8z7hncf4GY)

### Tod's Pick #2: Tiles from Bergsonne Labs

You know Qwiic/StemmaQT, the cabling standard by SparkFun & Adafruit. It enables
hundreds of different I2C devices in a consistent way, making prototyping ideas faster.
But if it can get bulky fast. What if there was a micro-sized similar standard?
There may be! It's called Tiles from Bergsonne Labs.

While Tiles are sort of like a micro version of the Qwiic/StemmQT standard,
they're targetting a more production-level market.
Each Tile board is only 4.0 mm x 4.0 mm big and has 10 connections for power, I2C & SPI.
They're meant to be soldered down on easily fabbed carrier boards, even flex circuit carriers
can work.

Remember these are 4mm squares, 4mm square is smaller than the regular NeoPixel LED we see everywhere.
In that 4mm square, a Tile module can be a full BLE microcontroller circuit, a 6-axis IMU,
a LiPo battery management circuit, a haptic driver, a heart rate sensor, or many others.
There's currently 26 tiles under active development.

A carrier PCB with some tile modules can be small enough to be production ready. It's
taking the "design blocks" approach I mentioned before and making it physical. The tile
modules are pre-verified and certified with their drivers being open source.

Tiles were created by Jonathan Fiene from the Max Planck Institute for Intelligent Systems,
and he created Bergsonne Labs in Germany to encourge the use of Tiles. Bergsonne is
working on an online design studio app to help create with Tiles. They've also created
some carrier boards with ZIF-sockets to let you try out Tile modules without soldering.
I got to play with Tiles a bit a few weeks ago and it's hard to describe just how small
they are. 4mm! Smaller than your fingernail.  It's incredible.  It's very early days for Tile,
but I love this modular approach of tried-n-true circuits. I can see new products being
composed entirely from Tiles for an initial production run.

Links:
  - [About Tiles](https://www.bergsonnelabs.com/tiles)
  - [Tile Reference Sets](https://www.bergsonnelabs.com/reference-sets)
  - [Tile library](https://bergsonnelabs.notion.site/27c94a2cf4c680dab209ecd4024445ee?v=27c94a2cf4c6801fb000000c7c766957)
